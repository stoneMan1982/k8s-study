# 云原生技术学习

## Docker

### 容器的本质   

容器的本质实际上是一个视图被隔离，资源受限的进程。

### 创建一个使用宿主机主机名的容器：  
- docker run --hostname $(hostname) -d --name my_container ubuntu:latest

### docker run -t  

使用了-t参数，这样会为容器分配一个伪终端(pseudo-TTY)  
TTY保持容器存活，即使PID 1(容器主进程)进程被杀死，docker守护进程会检测到这种情况并自动重启PID 1(容器主进程)进程。  

### docker 1号进程   

在Linux系统中：  
- PID 1是第一个用户空间进程，由内核在启动时创建，通常是init或systemd  


在docker容器中：  
- Dockerfile中CMD或ENTRYPOINT指定的主进程  
- 容器生命周期=1号进程/主进程的生命周期
- 容器生命周期确实由“该容器自己的主进程”决定，但不一定是 PID 1。

### docker run --pid container:<name|id>  

常见取值与作用：

--pid=host：共享宿主机的 PID 命名空间，容器内可看到宿主机所有进程。  
--pid=container:<name|id>：共享指定容器的 PID 命名空间，容器内可看到那个容器的进程，并可向其发送信号。  
默认（不写）：使用独立的 PID 命名空间，容器只看到自身进程。  

影响：  

- ps/top 显示的是共享命名空间里的进程集合。  
- 共享后可对对方进程发信号（需要权限），例如 kill 1。  
- 不会自动共享文件系统、网络等，只有 PID 空间被共享。  

例子：  

```sh
docker run -d -t --name demo ubuntu top 
docker run --name demo-x --pid container:demo ubuntu ps
```

--pid=container:demo 只是共享 PID 命名空间，demo-x 的主进程在这个命名空间里可能是 PID 2、3…，不是 PID 1。Docker 仍然以 demo-x 的主进程是否存活来判断它的生命周期。
所以杀掉共享命名空间里的 PID 1 会让 demo 退出，但 demo-x 只要自己的主进程还活着就不会退出。

其他进程都是1号进程的后代。1号进程负责回收所用孤儿进程，这些孤儿进程会被重新指定给1号进程，即以1号进程为父进程。  


## Kubernetes  

### Pod  

Pod是k8s中一个重要的概念，它是k8s调度的最小单元（原子单位），由各多个容器组成。从逻辑上来说，Pod类似与一个进程组（容器组），管理着多个进程（容器）。在同一个Pod中的容器具有着“超亲密”的关系：  

- 比如两个容器之间会发生文件交换，如：一个写日志，一个读日志  
- 两个容器之间要通过localhost或者本地socket去进行通信  
- 这个两个容器之间或者是微服务之间，需要发生频繁的RPC调用，出于性能考虑，也希望他们是超亲密关系  
- 两个容器或应用，他们需要共享某些Linux Namespace，如：一个容器需要加入另一个容器的Network Namespace，这样他们就能看到相同的网络设备和网络信息。  

像以上的情况，在k8s中都是用Pod的概念来解决的。  

#### 为什么Pod必须是原子调度单位   

因为Pod中的容器需要共享网络、存储、进程名称空间，这些共享必须在同一个物理节点上才能实现，容器分不到不同节点无法工作。  

- 网络命名空间共享  

```yaml
spec:
  containers:
    - name: app
      image: myapp:v1  
      ports:
        - containerPort: 3000
    - name: sidecar
      image: logging-agent:v1
      ports:
        - containerPort: 9090
```

**关键事实：**  
- 这些容器共享同一个IP  
- 通过localhost互相通信  
- 共享网络栈(iptables,路由表等)

如果分散到不同节点，容器无法通过localhost通信，网络栈被分割，Pod的设计初衷被破坏

- 存储卷共享  

```yaml
spec:
  containers:
    - name: app
      volumeMounts:
        - name: shared-data
          mountPath: /data
    - name: sidecar
      volumeMounts:
        - name: shared-data
          mountPath: /var/log
  volumes:
    - name: shared-data
      emptyDir: {}
```

场景：应用写日志到/data，sidecar从/var/log读取处理  
如果分散到不同节点，同一个卷在不同节点上是**不同的物理存储**，容器无法共享数据

- 进程通信需求  

```yaml
spec:
  containers:
    - name: app
      lifecycle:
        preStop:
          exec:
            command: ["/bin/sh", "-c", "sleep 15"]
    - name: network-helper
```

应用优雅关闭时需要sidecar帮助清理网络连接，如果分散到不同节点，两个容器无法同步，优雅关闭失败。  

- 从启停方式：

```sh
kubectl apply -f pod-with-2-containers.yaml

# 期望：
# 两个容器被调度到同一个节点
# 一起启动，一起停止
```

如果不是原子调度：  

可能的调度结果：  

1. app调度成功，sidecar失败  
  -> Pod永远pending，应用无法运行  

2. sidecar调度成功，app失败  
  -> 独立的sidecar没有意义  

3. 分别调度到不同节点  
  -> 网络、存储无法共享，功能破坏  

#### 如何共享网络  

比如现在有个Pod，其中包含了container A和container B，他们两个需要共享Network Namespace。在k8s中，它会在每个Pod里额外启动一个infra container小容器来共享整个Pod的Network Namespace,其他所有容器都会通过Join Namespace的方式加入到infra container的Network Namespace中。  

在Pod里，一定有一个IP地址，是这个Pod的Network Namespace对应的地址，也是这个Infra container的IP地址。  

所以整个Pod里面，必然是Infra contianer第一个启动，并且整个Pod的生命周期等同于Infra container的生命周期，与container A和container B无关。 

#### 如何共享存储  

把volume变成Pod level就可以了

### k8s资源对象  

- 工作负载（workload）资源  
用于运行应用的控制器：  

1. Pod

   k8s的最小调度单位，包含>=1个容器

2. Deployment
   无状态应用，如Web服务、API、微服务  

3. StatefulSet
   有状态应用，如MySql、MongoDB、Kafka  

4. DaemonSet
   每节点一个Pod，日志采集、监控agent  

5. Job
   一次性任务，批处理、数据迁移  

6. CronJob
   定时任务，定时备份、清理任务  

7. ReplicaSet
   副本管理，通常被Deployment管理，不直接使用

示例：  

```yaml

# Deployment 
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3

---

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
spec:
  serviceName: mysql
  replicas: 3

```

- 服务发现与负载均衡

1. Service  
   
   服务发现与负载均衡，提供稳定的访问入口  
   - ClusterIP  
     集群内部访问
   - NodePort  
     通过节点端口暴露服务，可以外部访问
   - LoadBalancer  
     云厂商提供负载均衡

  示例：  
  ```yaml

  apiVersion: v1
  kind: Service
  metadata:
    name: my-service
  spec:
    type: ClusterIP
    ports:
      - port: 80

  ---
  spec:
    type: NodePort
    ports:
      - port: 80
        nodePort: 30000

  ```

2. Ingress  

   HTTP/HTTPS路由，7层负载均衡

3. EndpointSlice  
   
   服务端点，service的后端Pod列表

4. NetworkPolicy  

   网络隔离策略，Pod间的访问控制

- 配置与存储  

1. ConfigMap  
  
   非敏感数据，配置文件，环境变量等

2. Secret  

   敏感数据，密码、证书、Token等

示例：  

```yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  database.url: "abc"
  log.level: "INFO"

---

# Secret - 敏感数据
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
type: Opaque
data:
  username: YWRtaW4=        # base64编码
  password: cGFzc3dvcmQ=


```

- 身份与权限  

- 集群管理  

- 自动扩缩容  

### 如何描述k8s资源  

每个k8s资源都遵循这个通用结构：  

```yaml

apiVersion: v1        # <- API版本
kind: Pod             # <- 资源类型
metadata:             # <- 资源元数据
  name: my-pod
  namespace: dev
  labels:
    app: myapp
  annotations:
    description: "My Pod"
spec:                 # <- 规格（期望状态）
  containers:
    - name: myapp
      image: myapp:latest
status:               # <- 状态（当前状态，由k8s自动更新，用户无法指定）k8s观察到的状态
  phase: Running
  podIP: 10.0.0.5

```

#### apiVersion  

指定使用哪个API版本：  

```yaml

# 核心API资源
apiVersion: v1
kind: Pod

# 应用API资源 
apiVersion: apps/v1
kind: Deployment

# 网络API资源
apiVersion: networking.k8s.io/v1
kind: Ingress

# RBAC API资源
apiVersion: rbac.authorization.k8s.io/v1
kind: Role

# 存储API资源
apiVersion: storage.k8s.io/v1
kind: StorageClass

```

可以通过命令：  

```sh
kubectl api-versions
```
查看所有API版本  

#### metadata - 元数据  

定义资源的基本信息：  

```yaml

metadata:
  # 必选：资源名称（同一namespace中唯一）
  name: my-deployment   

  # 可选：命名空间（默认为default）
  namespace: dev 

  # 可选：标签（用于选择、分组metadata:
  # 必选：资源名称（在同一namespace内唯一）
  name: my-deployment
  
  # 可选：命名空间（默认为default）
  namespace: dev
  
  # 可选：标签（用于选择、分组）
  labels:
    app: myapp           # 应用名
    version: v1.0        # 版本
    environment: prod    # 环境
    team: backend        # 团队
  
  # 可选：注解（元数据注释，不用于选择）
  annotations:
    description: "This is my production app"
    author: "John Doe"
    build-date: "2025-01-15"
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
  
  # 可选：所有者信息（通常由控制器自动设置）
  ownerReferences:
    - apiVersion: apps/v1
      kind: Deployment
      name: my-deployment
      uid: abc123

```

#### spec - 资源规格（核心部分）

定义资源的期望状态，这是最重要的部分  

不同的资源类型由不同的spec字段，以下是常用资源的详细示例：  

- Pod
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  # 容器列表
  containers:
    - name: app
      image: myapp:v1
      imagePullPolicy: IfNotPresent  # 镜像拉取策略
      ports:
        - containerPort: 8080
          protocol: TCP
      
      # 环境变量
      env:
        - name: DATABASE_URL
          value: "mysql://db:3306"
        - name: PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: password
      
      # 资源请求与限制
      resources:
        requests:
          cpu: 100m
          memory: 128Mi
        limits:
          cpu: 500m
          memory: 512Mi
      
      # 存储挂载
      volumeMounts:
        - name: config-volume
          mountPath: /etc/config
        - name: cache-volume
          mountPath: /cache
      
      # 存活探针（容器是否运行）
      livenessProbe:
        httpGet:
          path: /health
          port: 8080
        initialDelaySeconds: 10
        periodSeconds: 10
      
      # 就绪探针（容器是否能接收流量）
      readinessProbe:
        httpGet:
          path: /ready
          port: 8080
        initialDelaySeconds: 5
        periodSeconds: 5
  
  # 初始化容器（先于应用容器运行）
  initContainers:
    - name: init-db
      image: busybox:latest
      command: ['sh', '-c', 'echo waiting for db']
  
  # 存储卷
  volumes:
    - name: config-volume
      configMap:
        name: app-config
    - name: cache-volume
      emptyDir: {}
  
  # 重启策略
  restartPolicy: Always
  
  # 节点选择
  nodeSelector:
    kubernetes.io/hostname: node1
  
  # 污点容忍
  tolerations:
    - key: gpu
      operator: Equal
      value: "true"
      effect: NoSchedule
  
  # 亲和性
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
              - key: app
                operator: In
                values:
                  - myapp
          topologyKey: kubernetes.io/hostname
  
  # 服务账户
  serviceAccountName: my-app-sa
  
  # DNS策略
  dnsPolicy: ClusterFirst
  
  # 优雅关闭等待时间
  terminationGracePeriodSeconds: 30
```

- Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-deployment
spec:
  # 副本数
  replicas: 3
  
  # 更新策略
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1          # 最多比期望增加1个
      maxUnavailable: 1    # 最多不可用1个
  
  # 选择器（选择要管理的Pod）
  selector:
    matchLabels:
      app: myapp
  
  # Pod模板（创建Pod时使用）
  template:
    metadata:
      labels:
        app: myapp
        version: v1
    spec:
      containers:
        - name: app
          image: myapp:v1
          ports:
            - containerPort: 8080
```

### 应用编排和管理