# 云原生技术学习

## Docker

### 容器的本质   

容器的本质实际上是一个视图被隔离，资源受限的进程。

### 创建一个使用宿主机主机名的容器：  
- docker run --hostname $(hostname) -d --name my_container ubuntu:latest

### docker run -t  

使用了-t参数，这样会为容器分配一个伪终端(pseudo-TTY)  
TTY保持容器存活，即使PID 1(容器主进程)进程被杀死，docker守护进程会检测到这种情况并自动重启PID 1(容器主进程)进程。  

### docker 1号进程   

在Linux系统中：  
- PID 1是第一个用户空间进程，由内核在启动时创建，通常是init或systemd  


在docker容器中：  
- Dockerfile中CMD或ENTRYPOINT指定的主进程  
- 容器生命周期=1号进程/主进程的生命周期
- 容器生命周期确实由“该容器自己的主进程”决定，但不一定是 PID 1。

### docker run --pid container:<name|id>  

常见取值与作用：

--pid=host：共享宿主机的 PID 命名空间，容器内可看到宿主机所有进程。  
--pid=container:<name|id>：共享指定容器的 PID 命名空间，容器内可看到那个容器的进程，并可向其发送信号。  
默认（不写）：使用独立的 PID 命名空间，容器只看到自身进程。  

影响：  

- ps/top 显示的是共享命名空间里的进程集合。  
- 共享后可对对方进程发信号（需要权限），例如 kill 1。  
- 不会自动共享文件系统、网络等，只有 PID 空间被共享。  

例子：  

```sh
docker run -d -t --name demo ubuntu top 
docker run --name demo-x --pid container:demo ubuntu ps
```

--pid=container:demo 只是共享 PID 命名空间，demo-x 的主进程在这个命名空间里可能是 PID 2、3…，不是 PID 1。Docker 仍然以 demo-x 的主进程是否存活来判断它的生命周期。
所以杀掉共享命名空间里的 PID 1 会让 demo 退出，但 demo-x 只要自己的主进程还活着就不会退出。

其他进程都是1号进程的后代。1号进程负责回收所用孤儿进程，这些孤儿进程会被重新指定给1号进程，即以1号进程为父进程。  


## Kubernetes  

### Pod  

Pod是k8s中一个重要的概念，它是k8s调度的最小单元（原子单位），由各多个容器组成。从逻辑上来说，Pod类似与一个进程组（容器组），管理着多个进程（容器）。在同一个Pod中的容器具有着“超亲密”的关系：  

- 比如两个容器之间会发生文件交换，如：一个写日志，一个读日志  
- 两个容器之间要通过localhost或者本地socket去进行通信  
- 这个两个容器之间或者是微服务之间，需要发生频繁的RPC调用，出于性能考虑，也希望他们是超亲密关系  
- 两个容器或应用，他们需要共享某些Linux Namespace，如：一个容器需要加入另一个容器的Network Namespace，这样他们就能看到相同的网络设备和网络信息。  

像以上的情况，在k8s中都是用Pod的概念来解决的。  

#### 为什么Pod必须是原子调度单位   

因为Pod中的容器需要共享网络、存储、进程名称空间，这些共享必须在同一个物理节点上才能实现，容器分不到不同节点无法工作。  

- 网络命名空间共享  

```yaml
spec:
  containers:
    - name: app
      image: myapp:v1  
      ports:
        - containerPort: 3000
    - name: sidecar
      image: logging-agent:v1
      ports:
        - containerPort: 9090
```

**关键事实：**  
- 这些容器共享同一个IP  
- 通过localhost互相通信  
- 共享网络栈(iptables,路由表等)

如果分散到不同节点，容器无法通过localhost通信，网络栈被分割，Pod的设计初衷被破坏

- 存储卷共享  

```yaml
spec:
  containers:
    - name: app
      volumeMounts:
        - name: shared-data
          mountPath: /data
    - name: sidecar
      volumeMounts:
        - name: shared-data
          mountPath: /var/log
  volumes:
    - name: shared-data
      emptyDir: {}
```

场景：应用写日志到/data，sidecar从/var/log读取处理  
如果分散到不同节点，同一个卷在不同节点上是**不同的物理存储**，容器无法共享数据

- 进程通信需求  

```yaml
spec:
  containers:
    - name: app
      lifecycle:
        preStop:
          exec:
            command: ["/bin/sh", "-c", "sleep 15"]
    - name: network-helper
```

应用优雅关闭时需要sidecar帮助清理网络连接，如果分散到不同节点，两个容器无法同步，优雅关闭失败。  

- 从启停方式：

```sh
kubectl apply -f pod-with-2-containers.yaml

# 期望：
# 两个容器被调度到同一个节点
# 一起启动，一起停止
```

如果不是原子调度：  

可能的调度结果：  

1. app调度成功，sidecar失败  
  -> Pod永远pending，应用无法运行  

2. sidecar调度成功，app失败  
  -> 独立的sidecar没有意义  

3. 分别调度到不同节点  
  -> 网络、存储无法共享，功能破坏  

#### 如何共享网络  

比如现在有个Pod，其中包含了container A和container B，他们两个需要共享Network Namespace。在k8s中，它会在每个Pod里额外启动一个infra container小容器来共享整个Pod的Network Namespace,其他所有容器都会通过Join Namespace的方式加入到infra container的Network Namespace中。  

在Pod里，一定有一个IP地址，是这个Pod的Network Namespace对应的地址，也是这个Infra container的IP地址。  

所以整个Pod里面，必然是Infra contianer第一个启动，并且整个Pod的生命周期等同于Infra container的生命周期，与container A和container B无关。 

#### 如何共享存储  

把volume变成Pod level就可以了

### k8s资源对象  

- 工作负载（workload）资源  
用于运行应用的控制器：  

1. Pod

   k8s的最小调度单位，包含>=1个容器

2. Deployment
   无状态应用，如Web服务、API、微服务  

3. StatefulSet
   有状态应用，如MySql、MongoDB、Kafka  

4. DaemonSet
   每节点一个Pod，日志采集、监控agent  

5. Job
   一次性任务，批处理、数据迁移  

6. CronJob
   定时任务，定时备份、清理任务  

7. ReplicaSet
   副本管理，通常被Deployment管理，不直接使用

示例：  

```yaml

# Deployment 
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3

---

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
spec:
  serviceName: mysql
  replicas: 3

```

- 服务发现与负载均衡

1. Service  
   
   服务发现与负载均衡，提供稳定的访问入口  
   - ClusterIP  
     集群内部访问
   - NodePort  
     通过节点端口暴露服务，可以外部访问
   - LoadBalancer  
     云厂商提供负载均衡

  示例：  
  ```yaml

  apiVersion: v1
  kind: Service
  metadata:
    name: my-service
  spec:
    type: ClusterIP
    ports:
      - port: 80

  ---
  spec:
    type: NodePort
    ports:
      - port: 80
        nodePort: 30000

  ```

2. Ingress  

   HTTP/HTTPS路由，7层负载均衡

3. EndpointSlice  
   
   服务端点，service的后端Pod列表

4. NetworkPolicy  

   网络隔离策略，Pod间的访问控制

- 配置与存储  

1. ConfigMap  
  
   非敏感数据，配置文件，环境变量等

2. Secret  

   敏感数据，密码、证书、Token等

示例：  

```yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  database.url: "abc"
  log.level: "INFO"

---

# Secret - 敏感数据
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
type: Opaque
data:
  username: YWRtaW4=        # base64编码
  password: cGFzc3dvcmQ=


```

- 身份与权限  

- 集群管理  

- 自动扩缩容  

### 如何描述k8s资源  

每个k8s资源都遵循这个通用结构：  

```yaml

apiVersion: v1        # <- API版本
kind: Pod             # <- 资源类型
metadata:             # <- 资源元数据
  name: my-pod
  namespace: dev
  labels:
    app: myapp
  annotations:
    description: "My Pod"
spec:                 # <- 规格（期望状态）
  containers:
    - name: myapp
      image: myapp:latest
status:               # <- 状态（当前状态，由k8s自动更新，用户无法指定）k8s观察到的状态
  phase: Running
  podIP: 10.0.0.5

```

#### apiVersion  

指定使用哪个API版本：  

```yaml

# 核心API资源
apiVersion: v1
kind: Pod

# 应用API资源 
apiVersion: apps/v1
kind: Deployment

# 网络API资源
apiVersion: networking.k8s.io/v1
kind: Ingress

# RBAC API资源
apiVersion: rbac.authorization.k8s.io/v1
kind: Role

# 存储API资源
apiVersion: storage.k8s.io/v1
kind: StorageClass

```

可以通过命令：  

```sh
kubectl api-versions
```
查看所有API版本  

#### metadata - 元数据  

定义资源的基本信息：  

```yaml

metadata:
  # 必选：资源名称（同一namespace中唯一）
  name: my-deployment   

  # 可选：命名空间（默认为default）
  namespace: dev 

  # 可选：标签（用于选择、分组metadata:
  # 必选：资源名称（在同一namespace内唯一）
  name: my-deployment
  
  # 可选：命名空间（默认为default）
  namespace: dev
  
  # 可选：标签（用于选择、分组）
  labels:
    app: myapp           # 应用名
    version: v1.0        # 版本
    environment: prod    # 环境
    team: backend        # 团队
  
  # 可选：注解（元数据注释，不用于选择）
  annotations:
    description: "This is my production app"
    author: "John Doe"
    build-date: "2025-01-15"
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
  
  # 可选：所有者信息（通常由控制器自动设置）
  ownerReferences:
    - apiVersion: apps/v1
      kind: Deployment
      name: my-deployment
      uid: abc123

```

#### spec - 资源规格（核心部分）

定义资源的期望状态，这是最重要的部分  

不同的资源类型由不同的spec字段，以下是常用资源的详细示例：  

- Pod
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  # 容器列表
  containers:
    - name: app
      image: myapp:v1
      imagePullPolicy: IfNotPresent  # 镜像拉取策略
      ports:
        - containerPort: 8080
          protocol: TCP
      
      # 环境变量
      env:
        - name: DATABASE_URL
          value: "mysql://db:3306"
        - name: PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: password
      
      # 资源请求与限制
      resources:
        requests:
          cpu: 100m
          memory: 128Mi
        limits:
          cpu: 500m
          memory: 512Mi
      
      # 存储挂载
      volumeMounts:
        - name: config-volume
          mountPath: /etc/config
        - name: cache-volume
          mountPath: /cache
      
      # 存活探针（容器是否运行）
      livenessProbe:
        httpGet:
          path: /health
          port: 8080
        initialDelaySeconds: 10
        periodSeconds: 10
      
      # 就绪探针（容器是否能接收流量）
      readinessProbe:
        httpGet:
          path: /ready
          port: 8080
        initialDelaySeconds: 5
        periodSeconds: 5
  
  # 初始化容器（先于应用容器运行）
  initContainers:
    - name: init-db
      image: busybox:latest
      command: ['sh', '-c', 'echo waiting for db']
  
  # 存储卷
  volumes:
    - name: config-volume
      configMap:
        name: app-config
    - name: cache-volume
      emptyDir: {}
  
  # 重启策略
  restartPolicy: Always
  
  # 节点选择
  nodeSelector:
    kubernetes.io/hostname: node1
  
  # 污点容忍
  tolerations:
    - key: gpu
      operator: Equal
      value: "true"
      effect: NoSchedule
  
  # 亲和性
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
              - key: app
                operator: In
                values:
                  - myapp
          topologyKey: kubernetes.io/hostname
  
  # 服务账户
  serviceAccountName: my-app-sa
  
  # DNS策略
  dnsPolicy: ClusterFirst
  
  # 优雅关闭等待时间
  terminationGracePeriodSeconds: 30
```

- Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-deployment
spec:
  # 副本数
  replicas: 3
  
  # 更新策略
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1          # 最多比期望增加1个
      maxUnavailable: 1    # 最多不可用1个
  
  # 选择器（选择要管理的Pod）
  selector:
    matchLabels:
      app: myapp
  
  # Pod模板（创建Pod时使用）
  template:
    metadata:
      labels:
        app: myapp
        version: v1
    spec:
      containers:
        - name: app
          image: myapp:v1
          ports:
            - containerPort: 8080
```

### 应用编排和管理

#### Deployment  

一个Deployment为Pod和ReplicaSet提供声明式的更新能力。  

You describe a desired state in a Deployment, and the Deployment controller changes the actual state to the desired state at a controlled rate.

- spec 关键字段解析  

  1. MinReadySeconds: Deployment会根据Pod ready来看Pod是否可用，但是如果我们设置了MinReadySeconds之后，比如设置为30s，那Deployment就一定会等Pod ready30s之后才任务Pod是available的。pod available的前提是pod ready.  

  2. progressDeadlineSeconds: 前面提到当Deployment处于扩容或者发布状态时，它的condition会处于一个processing的状态，processing可以设置一个超时时间。如果超过超时时间还处于processing，那么controller将认为这个pod会进入failed状态。  

- 升级策略字段解析  
  Deployment在Rollingupdate中主要提供了连个策略，一个是MaxUnavailable，另一个是MaxSurge。  
  用于控制Pod的创建和删除策略

  1. MaxUnavailable: 
    - 作用： 更新时最多允许多少个Pod处于不可用状态  
    - 取值： 数字或百分比  
    - 含义： 允许提前删除旧Pod，但会短暂降低可用容量  

  2. MaxSurge
     - 作用：更新时最多可以超出期望副本数多少个Pod  
     - 取值：数字或百分比  
     - 含义：允许临时创建额外的Pod加快更新速度



- 回滚  

```sh
kubectl rollout undo deployment/<name>-deployment
```

- Pod名称生产规则  

Pod名称由三部分组成：  

<deployment-name>-<replicaset-hash>-<random-suffix>
     ①              ②                    ③

1. Deployment 名称  
  - 来源：metadata.name 字段

2. ReplicaSet 哈希值  
  - 来源：基于Pod template生成的hash 
  - 特点：同一个Pod template生成相同的hash；修改镜像/配置会生成新的hash；用于区分滚动更新的不同版本。

3. 随机后缀
  - 来源：Kubenetes 自动生成
  - 长度：5个字符

完整命名流程： 

```txt
1. 创建 Deployment
   nginx-deployment
   ↓
2. Deployment 创建 ReplicaSet
   nginx-deployment-7d9c8b5f4d
   (基于 pod template 计算 hash)
   ↓
3. ReplicaSet 创建 Pod
   nginx-deployment-7d9c8b5f4d-k8s2m
   nginx-deployment-7d9c8b5f4d-p7xwq
   (添加随机后缀确保唯一性)
```


#### Job   

主要是用来做一些一次性或重复性的定时工作。  

- Kubernetes的Job是一个管理任务的控制器，它可以创建一个或者多个Job，并可以监控它是否成功地运行或终止；  

- 可以根据Pod的状态设置重置的方式和重试的次数；  

- 可以根据依赖关系，指定Pod的运行顺序；  

- 可以控制Pod的并行度；

#### DaemonSet  

DaemonSet也是Kubernetes提供的一个default controller,它实际上一个守护进程的控制器，可以帮我们做到以下几件事：  

- 首先保证集群内的每一个节点都运行一组相同的Pod；  
- 同时还能根据节点的状态保证新加入的节点自动创建对应的Pod；  
- 在移除节点时，能删除对应的Pod；  
- 而且它会跟踪每个Pod的状态，当这个Pod出现异常，会及时地去recovery这个状态

DaemonSet的更新策略有两种：RollingUpdate和OnDelete


### 应用配置管理  

- 可变的配置  
ConfigMap

- 敏感信息的存储和使用，如：密码、token  
Secret  

- 身份认证  
ServiceAccount  

- 资源需求  
Resources  


- 容器的安全管控  
SecurityContext  

- 容器启动之前的  
InitContainer  


#### ConfigMap  

管理一些可变信息，如：配置文件、环境变量和命令行参数  
用于解耦容器镜像和可变配置  

使用要点：  

- ConfigMap文件的大小现在在1MB以内，ETCD的要求  
- Pod在使用ConfigMap时，必须是相同的Namespace中的ConfigMap  
- Pod引用的ConfigMap不存在时，这个Pod无法创建成功，ConfigMap要先于引用它的Pod创建  
- 只有通过k8s api创建的Pod才能使用ConfigMap

#### Secret  

Secret时k8s中主要用来存储密码、token等一些敏感信息的资源对象。其中敏感信息是通过base64编码保护起来的。  

metadata主要关注name、namespace两个字段；  

type是一个很重的字段，是指Secret的一个类型，常用的有：  

- Opaque，普通的Secret文件  
- service-account-token，是用于service-account身份认证的secret  
- dockerconfigjson，是拉取私有仓库镜像用的一种  
- bootstrap.token，是用于节点接入集群校验用的

#### ServiceAccount   

#### Resource   

#### SecurityContext  

#### InitContainer